---
id: actor-events
title: Actor events & state persistence
---

import CodeBlock from '@theme/CodeBlock';

import ActorEventsExample from '!!raw-loader!./code/04_actor_events.py';

During its runtime, the Actor receives Actor events sent by the Apify platform or generated by the Apify SDK itself.

## Event types

<table>
    <thead>
        <tr>
            <th>Event</th>
            <th>Data</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>SYSTEM_INFO</code></td>
            <td><pre>{`{
  "created_at": datetime,
  "cpu_current_usage": float,
  "mem_current_bytes": int,
  "is_cpu_overloaded": bool
}`}
            </pre></td>
            <td>
                <p>This event is emitted regularly and it indicates the current resource usage of the Actor.</p>
                The <code>is_cpu_overloaded</code> argument indicates whether the current CPU usage is higher than <code>Config.max_used_cpu_ratio</code>
            </td>
        </tr>
        <tr>
            <td><code>MIGRATING</code></td>
            <td><code>None</code></td>
            <td>
                <p>Emitted when the Actor running on the Apify platform
                is going to be <a href="https://docs.apify.com/platform/actors/development/state-persistence#what-is-a-migration">migrated</a>
                {' '}to another worker server soon.</p>
                You can use it to persist the state of the Actor so that once it is executed again on the new server,
                it doesn't have to start over from the beginning.
                Once you have persisted the state of your Actor, you can call <a href="../../reference/class/Actor#reboot"><code>Actor.reboot</code></a>
                to reboot the Actor and trigger the migration immediately, to speed up the process.
            </td>
        </tr>
        <tr>
            <td><code>ABORTING</code></td>
            <td><code>None</code></td>
            <td>
                When a user aborts an Actor run on the Apify platform,
                they can choose to abort gracefully to allow the Actor some time before getting killed.
                This graceful abort emits the <code>ABORTING</code> event which you can use to finish all running tasks and do cleanup.
            </td>
        </tr>
        <tr>
            <td><code>PERSIST_STATE</code></td>
            <td><pre>{`{ "is_migrating": bool }`}</pre></td>
            <td>
                <p>Emitted in regular intervals (by default 60 seconds) to notify the Actor that it should persist its state,
                in order to avoid repeating all work when the Actor restarts.</p>
                <p>This event is also emitted automatically when the <code>MIGRATING</code> event happens,
                in which case the <code>is_migrating</code> flag is set to <code>True</code>.</p>
                Note that the <code>PERSIST_STATE</code> event is provided merely for user convenience,
                you can achieve the same effect by persisting the state regularly in an interval and listening for the migrating event.
            </td>
        </tr>
    </tbody>
</table>

## Adding handlers to events

To add handlers to these events, you use the [`Actor.on`](../../reference/class/Actor#on) method,
and to remove them, you use the [`Actor.off`](../../reference/class/Actor#off) method.

<CodeBlock className="language-python">
    {ActorEventsExample}
</CodeBlock>
